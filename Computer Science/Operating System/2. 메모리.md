# 메모리

## 목차

- [개요](#개요)
- [핵심 용어](#핵심-용어)
- [메모리 계층](#321-메모리-계층)
    - [캐시](#캐시cache)
    - [캐시히트와 캐시미스](#캐시히트와-캐시미스)
- [메모리 관리](#322-메모리-관리)
    - [가상 메모리](#가상-메모리-virtual-memory)
    - [스레싱](#스레싱-thrashing)
    - [메모리 할당](#메모리-할당)
    - [페이지 교체 알고리즘](#페이지-교체-알고리즘)

## 개요
컴퓨터의 요소 중 메모리에 대해 알아본다.

## 핵심 용어
- `캐시`: 데이터를 미리 복사해 놓는 임시 저장소
- `가상 메모리`: 메모리 관리 기법의 하나로 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 기법
- `스와핑`: 메모리에서 사용되지 않는 일부 프로세스를 보조기억장치로 내보내고, 실행할 프로세스를 메모리에 적재하는 메모리 관리 기법'
- `페이지 폴트`: CPU가 프로그램을 실행하면서 필요한 페이지가 물리적 메모리에 없는 상황
- `스레싱`: CPU 작업 시간보다 메모리와 스왑 영역 간 페이지 교체에 시간을 많이 소비하는 것

## 3.2.1 메모리 계층

메모리 계층은 레지스터, 캐시, 메모리, 저장장치로 구성되었다.

- 레지스터: CPU 안에 있는 작은 메모리. 휘발성, 속도 가장 빠름, 기억 용량 가장 적음
- 캐시: L1, L2 캐시를 지칭. 휘발성, 속도 빠름, 기억 용량 적음. (+ L3 캐시도 존재한다)
- 주기억장치: RAM을 말한다. 휘발성, 속도 보통, 기억 용량 보통.
- 보조기억장치: HDD, SSD를 말한다. 비휘발성, 속도 낮음, 기억 용량 많음.

### 캐시(cache)

- 의미: 데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리

- 캐시를 사용함으로써 데이터를 접근하는 시간이 오래 걸리는 경우를 해결하고 무언가를 다시 계산하는 시간을 절약할 수 있다.

- 캐싱 계층: 속도 차이를 해결하기 위해 계층과 계층 사이에 있는 계층
    - ex) 캐시 메모리와 보조기억장치 사이에 있는 주기억장치를 보조기억장치의 캐싱 계층이라 지칭한다.

- **지역성의 원리**: 캐시 계층을 두지 않고 캐시를 직접 설정하는 경우 그 측도가 되는 원리
    - 시간 지역성: 최근 사용한 데이터에 다시 접근하려는 특성
    - 공간 지역성: 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성

### 캐시히트와 캐시미스

<img width="700" alt="image" src="https://github.com/k2645/basic-computer-science/assets/62226667/cca2edff-92ad-4d2c-8425-4e78a24a5541">

- 캐시히트: 캐시에서 원하는 데이터를 찾은 것
- 캐시미스: 원하는 데이터가 캐시에 없어 주메모리로 가서 데이터를 찾아오는 것

- 캐시매핑: 캐시가 히트되기 위해 미핑하는 방법을 말하며 CPU의 레지스터와 주메모리(RAM) 간 데이터를 주고받을 때를 기반으로 설명한다.
    |이름|설명|
    |-|-|
    |직접 매핑<br>(directed mapping)|매모리가 1~100이 있고 캐시가 1~10이 있다면 1:1~10, 2:1~20 ... 이런 식으로 매핑하는 것을 말한다.<br>처리가 빠르지만 충돌 발생이 잦다.|
    |연관 매핑<br>(associative mapping)|순서를 일치시키지 않고 관련 있는 캐시와 메모리를 매핑한다.<br>충돌이 적지만 모든 블록을 탐색해야하기 때문에 속도가 느리다.|
    |직접 연관 매핑<br>(set associative mapping)|직접 매핑과 연관 매핑을 합쳐놓은 것이다.<br>순서는 일치시키지만 집합을 둬서 저장하며 블록화되어 있기 대문에 검색은 조금 더 효율적이다.<br>예를 들어 메모리가 1~100이 있고 캐시가 1~10이 있다면 캐시 1~5에는 1~50의 데이터를 무작위로 저장시키는 것을 말한다.|

- 웹 브라우저의 캐시: 사용자의 커스텀한 정보나 인증모듈 관련 사항들을 웹브라우저에 저장해서 추후 서버에 요청할 때 자신을 나타내는 아이덴티티나 중복 요청 방지를 위해 쓰인다.
    - 쿠키
        - **만료기한이 있는 key-value 저장소**이다.
        - `same site` 옵션을 `strict`로 설정하지 않았을 경우 다른 도메인에서 요철했을 때 자동 전송된다.
        - 4KB까지 데이터를 저장할 수 있으며 만료기한을 정할 수 있다.
        - 쿠키 설정을 할 떈, `document.cookie`로 쿠키를 볼 수 없도록 `httponly` 옵션을 거는 것이 중요하다.
        - 만료기한은 클라이언트, 서버 모두 가능하지만 보통 서버에서 정한다.
    - 로컬 스토리지
        - **만료기한이 없는 key-value 저장소**이다.
        - 10MB까지 저장할 수 있으며 **웹브라우저를 닫아도 유지**되고 **도메인 단위로 저장, 생성**된다.
        - HTML5를 지원하는 웹브라우저에서만 사용 가능하며 **클라이언트에서만 수정 가능**하다.
    - 세션 스토리지
        - **만료기한이 없는 key-value 저장소**이다.
        - **탭 단위로 생성**하며, 탭을 닫을 때 해당 데이터가 삭제된다.
        - 5MB까지 저장할 수 있다.
        - HTML5를 지원하는 웹브라우저에서만 사용 가능하며 **클라이언트에서만 수정 가능**하다.

- 데이터베이스의 캐싱 계층: 메인 데이터베이스 위에 레디스(redis) 데이터베이스 계층을 '캐싱 계층'으로 두어 성능을 향상시키기도 한다.

## 3.2.2 메모리 관리

### 가상 메모리 (virtual memory)

- 의미: 메모리 관리 기법의 하나로 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용자들에게 매우 큰 메모리로 보이게 만드는 것
    - **가상 주소**(logical address): 가상적으로 주어진 주소
    - **실제 주소**(physical address): 실제 메모리상에 있는 주소

- 특징
    - 메모리관리장치(MMU)를 통해 가상 주소가 실제 주소로 변환된다.
    - 가상 메모리는 가상 주소와 실제 주소가 매핑되어 있다.
    - 프로세스의 주소 정보가 들어있는 **'페이지 테이블'** 로 관리된다.
    - 속도 향상을 위해 [TLB](#tlb)를 사용한다.

- **스와핑(swapping)**
    - 메모리에서 당장 사용하지 않는 영역을 하드디스크로 옮기고 하드디스크의 일부분을 마치 메모리처럼 불러와 쓰는 것
    - 가상 메모리에는 존재하지만 RAM에는 없는 현재 데이터나 코드에 접근할 경우 페이지 폴트가 발생하게 된다. <br> -> 이때 스와핑을 통해 페이지 폴드가 일어나지 않은 것처럼 만든다.

- **페이지 폴트(page fault)**
    - 프로세스의 주소 공간에는 존재하지만 지금 이 컴퓨터의 RAM에는 없는 데이터에 접근했을 경우 발생한다.
    
- 페이지 폴트와 스와핑 과정
    1. CPU는 물리 메모리를 확인하여 해당 [페이지](#페이지page)가 없으면 트랩을 발생시켜 OS에 알린다.
    2. OS는 CPU의 동작을 잠시 멈춘다.
    3. OS는 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인하고, 없다면 프로세스를 중단하고 현재 물리 메모리에 비어 있는 [프레임](#프레임frame)이 있는지 찾는다. 물리 메모리에도 없으면 이때 스와핑이 발동된다.
    4. 비어 있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화한다.
    5. 중단되었던 CPU를 다시 작동시킨다.

### 스레싱 (thrashing)

- 메모리의 페이지 폴트율이 높은 것을 의미하며, 이는 컴퓨터의 심각한 성능 저하를 초래한다.
    <img width="400" alt="image" src="https://github.com/k2645/basic-computer-science/assets/62226667/8e124b86-c369-4fe0-8e31-e61c75f3b056">

- 스레싱이 일어나는 경위
    1. 메모리에 너무 많은 프로세스가 동시에 올라가게 되면 스와핑이 많이 일어난다. (=페이지 폴트가 많이 발생한다.)
    2. 페이지 폴트가 일어나면 CPU 이용률이 감소한다.
    3. CPU 이용률이 감소하면 OS는 CPU 가용성을 더 높이기 위해 더 많은 프로세스를 메모리에 올리게 된다.
    4. 위 악순환이 반복되며 스레싱이 일어난다.

- 스레싱 해결 방법
    - 물리 메모리를 늘리거나, HDD를 SSD로 바꾼다.
    - **작업세트(working set)**
        - 프로세스의 과거 사용 이력인 지역성(locality)을 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드하는 것
        - 미리 메모리에 로드하면 탐색에 드는 비용을 줄일 수 있고 스와핑 또한 줄일 수 있다.
    - **PFF(Page Fault Frequency)**
        - 에피지 폴트 빈도를 조절하는 방법으로 상한선과 하한선을 만든다.
        - 상한성에 도달하면 프레임을 늘리고 하한선에 도달하면 프레임을 줄인다.
    
### 메모리 할당

- 시작 메모리 위치, 메모리의 할당 크기를 기반으로 할당하는데, 연속 할당과 불연속 할당으로 나뉜다.

- **연속 할당**
    - 메모리에 '연속적으로' 공간을 할당하는 것
    - 고정 분할 방식과 가변 분할 방식이 있다.
    - **고정 분할 방식**(fixed partition allocation): 메모리를 미리 나누어 관리하는 방식으로 메모리가 미리 나뉘어 있기 때문에 **융통성이 없고** **[내부 단편화](#내부-단편화internal-fragmentation)**가 발생한다는 특징이 있다. 
    - **가변 분할 방식**(variable partition allocation): 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용한다. 내부 단편화는 발생하지 않고 **[외부 단편화](#외부-단편화external-fragmentation)는 발생할 수 있다**. 
    - 가변 분할 방식 종류
        |이름|설명|
        |-|-|
        |최초적합(first fit)|위쪽이나 아래쪽부터 시작해서 [홀](#홀hole)을 찾으면 바로 할당한다.|
        |최적적합(best fit)|프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당한다.|
        |최악적합(worst fit)|프로세스의 크기와 가장 차이가 많이 나는 홀에 할당한다.|

- **불연속 할당**
    - 메모리를 연속적으로 할당하지 않는 것
        |이름|설명|
        |-|-|
        |페이징(paging)|동일한 크기의 **페이지 단위**로 나누어 메모리의 서로 다른 위치에 프로세스를 할당한다.<br>**홀의 크기가 균일**해지지만 **주소 변환이 복잡**해진다.|
        |세그멘테이션(segmentation)|의미 단위인 **세그먼트(Segment)로 나누**는 방식이다. <br>프로세스는 코드, 데이터, 스택, 힙 등으로 이루어지는데, 코드와 데이터 등 이를 기반으로 나눌 수도, 함수 단위로 나눌 수도 있다.<br>**공유와 보안** 측면에서 좋으며 **홀 크기가 균일하지 않은 문제**가 발생한다.|
        |페이지드 세그멘테이션(paged segmentation)|공유나 보안을 의미 단위의 세그먼트로 나누고, 물리적 메모리는 페이지로 나누는 것|

### 페이지 교체 알고리즘

- 오프라인 알고리즘(offline algorithm)
    - 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘이며 가장 좋은 알고리즘.
    - but, 미래에 참조되는 프로세스를 알 수 없으므로 **사용할 수 없는 알고리즘**이며 성능 비교에 대한 기준을 제공한다. *(~~왜..있는거임..?~~)*

- FIFO(First In First Out)
    - 가장 먼저 들어온 페이지를 교체 영역에 가장 먼저 놓는 방법
    - Queue 알고리즘..

- LRU(Least Recentle Used)
    - 참조가 가장 오래된 페이지를 바꾼다.
    - '오래된' 것을 파악하기 위해 각 페이지마다 계수기, 스택을 두어야 하는 문제가 있다.
    - 해시 테이블과 이중 연결 리스트 자료 구조로 구현한다.

    ```python
    from collections import OrderedDict

    class LRUCache:
        def __init__(self, capacity):
            self.cache = OrderedDict()
            self.capacity = capacity

        def refer(self, key):
            if key not in self.cache:
                if len(self.cache) >= self.capacity:
                    # 가장 최근에 사용되지 않은 항목(캐시의 마지막 항목)을 제거
                    self.cache.popitem(last=False)
            else:
                # 키가 캐시에 있으면, 삭제 후 다시 삽입하여 최근 사용으로 갱신
                self.cache.move_to_end(key)
                print(f"지웁니당! : {key}")
            # 항목을 캐시의 가장 최근 사용으로 업데이트
            self.cache[key] = True

        def display(self):
            # 캐시의 현재 상태를 출력
            print(' '.join([str(key) for key in self.cache.keys()]))
            print("\n", end='')

    # 메인 함수
    if __name__ == "__main__":
        ca = LRUCache(3)
        ca.refer(1)
        ca.display()
        ca.refer(3)
        ca.display()
        ca.refer(0)
        ca.display()
        ca.refer(3)
        ca.display()
        ca.refer(5)
        ca.display()
        ca.refer(6)
        ca.display()
        ca.refer(3)
        ca.display()

    ```

- NUR(Not Used Recently)
    - 0과 1을 가진 비트를 두고 시계 방향으로 돌면서 0을 찾고 0을 0을 찾은 순간 해당 프로세스를 교체하고, 해당 부분을 1로 바꾸는 알고리즘
    - 1은 최근 참조되었고 0은 참조되지 않음을 의미
    - LRU의 발전된 버전

- LFU(Least Frequently Used)
    - 가장 참조 횟수가 적은 페이지를 교체

## 그 외 용어

#### TLB
- 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시
- 페이지 테이블에 있는 리스트를 보관하며 CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상시킬 수 있는 캐시 계층

#### 페이지(page)
- 가상 메모리를 사용하는 최소 크기 단위

#### 프레임(frame)
- 실제 메모리를 사용하는 최소 크기 단위

#### 내부 단편화(internal fragmentation)
- 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상

#### 외부 단편화(external fragmentation)
- 메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 현상

#### 홀(hole)
- 할당할 수 있는 비어 있는 메모리 공간

## 참고 자료

- 블로그
    - [가상메모리와 페이지폴트](https://velog.io/@jiseong/OS-%EA%B0%80%EC%83%81%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%80%ED%8F%B4%ED%8A%B8-gyq8tftz)
    - [스레싱이란 무엇인가요?](https://velog.io/@haden/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%8A%A4%EB%A0%88%EC%8B%B1%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94)